<!DOCTYPE html>
<html>

<head>
    <title>Scacchiera</title>

    <!-- chessboard.css -->
    <style>
        :root {
            --dimBoard: 600px;
            --pieceRatio: 0.9;

            --blackSquare: #b58863;
            --whiteSquare: #f0d9b5;
            --highlightSquare: yellow;
            --selectedSquareWhite: #ababaa;
            --selectedSquareBlack: #ababaa;
            --movedSquareBlack: #e9e981;
            --movedSquareWhite: #f1f1a0;
            --choiceSquare: white;
            --coverSquare: black;
            --hintColor: #ababaa;
        }

        .board {
            display: grid;
            grid-template: repeat(8, 1fr) / repeat(8, 1fr);
            width: var(--dimBoard);
            height: var(--dimBoard);
            background-color: var(--blackSquare);
        }

        .square {
            width: calc(var(--dimBoard) / 8);
            height: calc(var(--dimBoard) / 8);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece {
            position: absolute;
            z-index: 10;
            width: calc(calc(var(--dimBoard) / 8) * var(--pieceRatio));
            height: calc(calc(var(--dimBoard) / 8) * var(--pieceRatio));

            /* No selection */
            -webkit-user-select: none;
            /* Safari */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE10+/Edge */
            user-select: none;
            /* Standard */
        }

        .choicable {
            z-index: 25;
        }

        .hint {
            background: var(--hintColor);
            width: calc(calc(var(--dimBoard) / 8) / 3.5);
            height: calc(calc(var(--dimBoard) / 8) / 3.5);
            position: absolute;
            z-index: 5;
            border-radius: 50%;
            opacity: 0.8;
        }

        .catchable {
            width: calc(calc(var(--dimBoard) / 8) * 0.9);
            height: calc(calc(var(--dimBoard) / 8) * 0.9);
        }

        .blackSquare {
            background: var(--blackSquare);
        }

        .whiteSquare {
            background: var(--whiteSquare);
        }

        .selectedSquareWhite {
            background: var(--selectedSquareWhite);
        }

        .selectedSquareBlack {
            background: var(--selectedSquareBlack);
        }

        .movedSquareBlack {
            background: var(--movedSquareBlack);
        }

        .movedSquareWhite {
            background: var(--movedSquareWhite);
        }

        .choice {
            background: var(--choiceSquare);
            z-index: 20;
        }

        .cover {
            background: var(--coverSquare);
            opacity: 0.5;
            z-index: 20;
        }

        .highlighted {
            box-shadow: inset 0 0 10px var(--highlightSquare);
        }
    </style>


    <style>
        body {
            /* Lato font */
            font-family: 'Lato', sans-serif;
            display: flex;
            justify-content: space-between;
            padding: auto;
        }

        .list_container {
            width: 350px;
            margin-right: 10px;
        }

        .collapsible {
            cursor: pointer;
            width: 100%;
            height: 50px;
            border: none;
            text-align: left;
            outline: none;
            font-size: 15px;
            margin-top: 8px;
            padding: 0 20px;
            border-radius: 7px;
            transition: all 0.2s;
            background-color: #f1f1f1;
        }

        .active,
        .collapsible:hover {
            background-color: #ddd;
        }

        .collapsible:after {
            content: '\2795';
            font-size: 13px;
            color: white;
            float: right;
            margin-left: 5px;
        }

        .active:after {
            content: "\2796";
        }

        .content {
            display: flex;
            flex-direction: column;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }

        .item {
            width: 100%;
            line-height: 50px;
            border-bottom: 1px solid #ccc;
            padding: 0 20px;
            font-size: 15px;
            transition: all 0.2s;
        }

        .item:hover {
            background-color: #f9f9f9;
        }

        /* CSS */
        .button-4 {
            appearance: none;
            background-color: #FAFBFC;
            border: 1px solid rgba(27, 31, 35, 0.15);
            border-radius: 6px;
            box-shadow: rgba(27, 31, 35, 0.04) 0 1px 0, rgba(255, 255, 255, 0.25) 0 1px 0 inset;
            box-sizing: border-box;
            color: #24292E;
            cursor: pointer;
            display: inline-block;
            font-family: -apple-system, system-ui, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            font-size: 14px;
            font-weight: 500;
            line-height: 20px;
            list-style: none;
            padding: 6px 16px;
            position: relative;
            transition: background-color 0.2s cubic-bezier(0.3, 0, 0.5, 1);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            vertical-align: middle;
            white-space: nowrap;
            word-wrap: break-word;
        }

        .button-4:hover {
            background-color: #F3F4F6;
            text-decoration: none;
            transition-duration: 0.1s;
        }

        .button-4:disabled {
            background-color: #FAFBFC;
            border-color: rgba(27, 31, 35, 0.15);
            color: #959DA5;
            cursor: default;
        }

        .button-4:active {
            background-color: #EDEFF2;
            box-shadow: rgba(225, 228, 232, 0.2) 0 1px 0 inset;
            transition: none 0s;
        }

        .button-4:focus {
            outline: 1px transparent;
        }

        .button-4:before {
            display: none;
        }

        .button-4:-webkit-details-marker {
            display: none;
        }

        #right {
            width: 600px;
            height: fit-content;
            margin-top: 10px;
            padding: 10px;
        }

        #buttonContainer {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            gap: 10px;
        }

        #textContainer {
            width: auto;
            height: fit-content;
            max-height: 100px;
            margin-top: 10px;
            border: 1px solid #ccc;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            transition: all 0.2s;
            padding: 10px 20px;
        }

        #explanations {
            width: auto;
            margin-top: 10px;
            height: fit-content;
            line-height: 1.5;
        }

        #boardContainer {
            margin: 20px 0;
        }

        #title {
            font-size: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }

        #codeContainer {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-left: 3px solid #f36d33;
            color: #666;
            font-family: monospace;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 1.6em;
            margin-top: 10px;
            max-width: 100%;
            padding: 1em 1.5em;
            white-space: nowrap
        }
    </style>


</head>

<body>

    <div class="list_container">

        <!-- Colonna Basic -->
        <div class="set">
            <button type="button" class="collapsible">Basic</button>
            <div class="content">
                <div class="item">Start position</div>
                <div class="item">Position FEN</div>
                <div class="item">Position Object</div>
                <div class="item">Orientation</div>
                <div class="item">Size</div>
            </div>
        </div>

        <!-- Colonna Configurations -->
        <div class="set">
            <button type="button" class="collapsible">Configurations</button>
            <div class="content">
                <div class="item">Draggable</div>
                <div class="item">Clickable</div>
                <div class="item">Mode</div>
                <div class="item">Movable colors</div>
                <div class="item">Animations</div>
                <div class="item">Pieces</div>
                <div class="item">Colors</div>
            </div>
        </div>

        <!-- Colonna Methods -->
        <div class="set">
            <button type="button" class="collapsible">Methods</button>
            <div class="content">
                <div class="item">Position (FEN)</div>
                <div class="item">Moves</div>
                <div class="item">State</div>
                <div class="item">Reset board</div>
                <div class="item">Destroy board</div>
                <div class="item">Hints</div>
                <div class="item">Selections</div>
                <div class="item">Highlights</div>
            </div>
        </div>

        <!-- Colonna Events -->
        <div class="set">
            <button type="button" class="collapsible">Events</button>
            <div class="content">
                <div class="item">onMove</div>
                <div class="item">onMoveEnd</div>
                <div class="item">onDragStart</div>
                <div class="item">onDragMove</div>
                <div class="item">onDrop</div>
                <div class="item">onSnapbackEnd</div>
                <div class="item">onChange</div>
            </div>
        </div>


    </div>

    <div id="right">
        <div id="title"></div>
        <div id="explanations"></div>
        <div id="boardContainer">
            <div id="board" style="width: 400px;"></div>
        </div>
        <div id="buttonContainer"></div>
        <div id="textContainer"></div>
        <div id="codeContainer"></div>

    </div>
    </div>

    <!-- chess.js -->
    <script>

        /* @license
 * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
 * Released under the BSD license
 * https://github.com/jhlywa/chess.js/blob/master/LICENSE
 */
        var Chess = function (r) { function e() { ur = new Array(128), lr = { w: x, b: x }, sr = U, pr = { w: 0, b: 0 }, cr = x, vr = 0, gr = 1, hr = [], dr = {}, a(i()) } function n() { t(H) } function t(r) { var n = r.split(/\s+/), t = n[0], f = 0; if (!o(r).valid) return !1; e(); for (var u = 0; u < t.length; u++) { var s = t.charAt(u); if ("/" === s) f += 8; else if (O(s)) f += parseInt(s, 10); else { var p = "a" > s ? U : Q; l({ type: s.toLowerCase(), color: p }, R(f)), f++ } } return sr = n[1], n[2].indexOf("K") > -1 && (pr.w |= er.KSIDE_CASTLE), n[2].indexOf("Q") > -1 && (pr.w |= er.QSIDE_CASTLE), n[2].indexOf("k") > -1 && (pr.b |= er.KSIDE_CASTLE), n[2].indexOf("q") > -1 && (pr.b |= er.QSIDE_CASTLE), cr = "-" === n[3] ? x : fr[n[3]], vr = parseInt(n[4], 10), gr = parseInt(n[5], 10), a(i()), !0 } function o(r) { var e = { 0: "No errors.", 1: "FEN string must contain six space-delimited fields.", 2: "6th field (move number) must be a positive integer.", 3: "5th field (half move counter) must be a non-negative integer.", 4: "4th field (en-passant square) is invalid.", 5: "3rd field (castling availability) is invalid.", 6: "2nd field (side to move) is invalid.", 7: "1st field (piece positions) does not contain 8 '/'-delimited rows.", 8: "1st field (piece positions) is invalid [consecutive numbers].", 9: "1st field (piece positions) is invalid [invalid piece].", 10: "1st field (piece positions) is invalid [row too large].", 11: "Illegal en-passant square" }, n = r.split(/\s+/); if (6 !== n.length) return { valid: !1, error_number: 1, error: e[1] }; if (isNaN(n[5]) || parseInt(n[5], 10) <= 0) return { valid: !1, error_number: 2, error: e[2] }; if (isNaN(n[4]) || parseInt(n[4], 10) < 0) return { valid: !1, error_number: 3, error: e[3] }; if (!/^(-|[abcdefgh][36])$/.test(n[3])) return { valid: !1, error_number: 4, error: e[4] }; if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(n[2])) return { valid: !1, error_number: 5, error: e[5] }; if (!/^(w|b)$/.test(n[1])) return { valid: !1, error_number: 6, error: e[6] }; var t = n[0].split("/"); if (8 !== t.length) return { valid: !1, error_number: 7, error: e[7] }; for (var o = 0; o < t.length; o++) { for (var i = 0, f = !1, a = 0; a < t[o].length; a++)if (isNaN(t[o][a])) { if (!/^[prnbqkPRNBQK]$/.test(t[o][a])) return { valid: !1, error_number: 9, error: e[9] }; i += 1, f = !1 } else { if (f) return { valid: !1, error_number: 8, error: e[8] }; i += parseInt(t[o][a], 10), f = !0 } if (8 !== i) return { valid: !1, error_number: 10, error: e[10] } } return "3" == n[3][1] && "w" == n[1] || "6" == n[3][1] && "b" == n[1] ? { valid: !1, error_number: 11, error: e[11] } : { valid: !0, error_number: 0, error: e[0] } } function i() { for (var r = 0, e = "", n = fr.a8; n <= fr.h1; n++) { if (null == ur[n]) r++; else { r > 0 && (e += r, r = 0); var t = ur[n].color, o = ur[n].type; e += t === U ? o.toUpperCase() : o.toLowerCase() } n + 1 & 136 && (r > 0 && (e += r), n !== fr.h1 && (e += "/"), r = 0, n += 8) } var i = ""; pr[U] & er.KSIDE_CASTLE && (i += "K"), pr[U] & er.QSIDE_CASTLE && (i += "Q"), pr[Q] & er.KSIDE_CASTLE && (i += "k"), pr[Q] & er.QSIDE_CASTLE && (i += "q"), i = i || "-"; var f = cr === x ? "-" : R(cr); return [e, sr, i, f, vr, gr].join(" ") } function f(r) { for (var e = 0; e < r.length; e += 2)"string" == typeof r[e] && "string" == typeof r[e + 1] && (dr[r[e]] = r[e + 1]); return dr } function a(r) { hr.length > 0 || (r !== H ? (dr.SetUp = "1", dr.FEN = r) : (delete dr.SetUp, delete dr.FEN)) } function u(r) { var e = ur[fr[r]]; return e ? { type: e.type, color: e.color } : null } function l(r, e) { if (!("type" in r && "color" in r)) return !1; if (-1 === W.indexOf(r.type.toLowerCase())) return !1; if (!(e in fr)) return !1; var n = fr[e]; return r.type == F && lr[r.color] != x && lr[r.color] != n ? !1 : (ur[n] = { type: r.type, color: r.color }, r.type === F && (lr[r.color] = n), a(i()), !0) } function s(r) { var e = u(r); return ur[fr[r]] = null, e && e.type === F && (lr[e.color] = x), a(i()), e } function p(r, e, n, t, o) { var i = { color: sr, from: e, to: n, flags: t, piece: r[e].type }; return o && (i.flags |= er.PROMOTION, i.promotion = o), r[n] ? i.captured = r[n].type : t & er.EP_CAPTURE && (i.captured = $), i } function c(r) { function e(r, e, n, t, o) { if (r[n].type !== $ || w(t) !== ir && w(t) !== nr) e.push(p(r, n, t, o)); else for (var i = [G, M, B, j], f = 0, a = i.length; a > f; f++)e.push(p(r, n, t, o, i[f])) } var n = [], t = sr, o = N(t), i = { b: or, w: tr }, f = fr.a8, a = fr.h1, u = !1, l = "undefined" != typeof r && "legal" in r ? r.legal : !0; if ("undefined" != typeof r && "square" in r) { if (!(r.square in fr)) return []; f = a = fr[r.square], u = !0 } for (var s = f; a >= s; s++)if (136 & s) s += 7; else { var c = ur[s]; if (null != c && c.color === t) if (c.type === $) { var v = s + z[t][0]; if (null == ur[v]) { e(ur, n, s, v, er.NORMAL); var v = s + z[t][1]; i[t] === w(s) && null == ur[v] && e(ur, n, s, v, er.BIG_PAWN) } for (g = 2; 4 > g; g++) { var v = s + z[t][g]; 136 & v || (null != ur[v] && ur[v].color === o ? e(ur, n, s, v, er.CAPTURE) : v === cr && e(ur, n, s, cr, er.EP_CAPTURE)) } } else for (var g = 0, E = J[c.type].length; E > g; g++)for (var b = J[c.type][g], v = s; ;) { if (v += b, 136 & v) break; if (null != ur[v]) { if (ur[v].color === t) break; e(ur, n, s, v, er.CAPTURE); break } if (e(ur, n, s, v, er.NORMAL), "n" === c.type || "k" === c.type) break } } if (!u || a === lr[t]) { if (pr[t] & er.KSIDE_CASTLE) { var _ = lr[t], y = _ + 2; null != ur[_ + 1] || null != ur[y] || h(o, lr[t]) || h(o, _ + 1) || h(o, y) || e(ur, n, lr[t], y, er.KSIDE_CASTLE) } if (pr[t] & er.QSIDE_CASTLE) { var _ = lr[t], y = _ - 2; null != ur[_ - 1] || null != ur[_ - 2] || null != ur[_ - 3] || h(o, lr[t]) || h(o, _ - 1) || h(o, y) || e(ur, n, lr[t], y, er.QSIDE_CASTLE) } } if (!l) return n; for (var m = [], s = 0, E = n.length; E > s; s++)S(n[s]), d(t) || m.push(n[s]), C(); return m } function v(r, e) { var n = ""; if (r.flags & er.KSIDE_CASTLE) n = "O-O"; else if (r.flags & er.QSIDE_CASTLE) n = "O-O-O"; else { var t = T(r, e); r.piece !== $ && (n += r.piece.toUpperCase() + t), r.flags & (er.CAPTURE | er.EP_CAPTURE) && (r.piece === $ && (n += R(r.from)[0]), n += "x"), n += R(r.to), r.flags & er.PROMOTION && (n += "=" + r.promotion.toUpperCase()) } return S(r), E() && (n += b() ? "#" : "+"), C(), n } function g(r) { return r.replace(/=/, "").replace(/[+#]?[?!]*$/, "") } function h(r, e) { for (var n = fr.a8; n <= fr.h1; n++)if (136 & n) n += 7; else if (null != ur[n] && ur[n].color === r) { var t = ur[n], o = n - e, i = o + 119; if (V[i] & 1 << Y[t.type]) { if (t.type === $) { if (o > 0) { if (t.color === U) return !0 } else if (t.color === Q) return !0; continue } if ("n" === t.type || "k" === t.type) return !0; for (var f = X[i], a = n + f, u = !1; a !== e;) { if (null != ur[a]) { u = !0; break } a += f } if (!u) return !0 } } return !1 } function d(r) { return h(N(r), lr[r]) } function E() { return d(sr) } function b() { return E() && 0 === c().length } function _() { return !E() && 0 === c().length } function y() { for (var r = {}, e = [], n = 0, t = 0, o = fr.a8; o <= fr.h1; o++)if (t = (t + 1) % 2, 136 & o) o += 7; else { var i = ur[o]; i && (r[i.type] = i.type in r ? r[i.type] + 1 : 1, i.type === B && e.push(t), n++) } if (2 === n) return !0; if (3 === n && (1 === r[B] || 1 === r[j])) return !0; if (n === r[B] + 2) { for (var f = 0, a = e.length, o = 0; a > o; o++)f += e[o]; if (0 === f || f === a) return !0 } return !1 } function m() { for (var r = [], e = {}, n = !1; ;) { var t = C(); if (!t) break; r.push(t) } for (; ;) { var o = i().split(" ").slice(0, 4).join(" "); if (e[o] = o in e ? e[o] + 1 : 1, e[o] >= 3 && (n = !0), !r.length) break; S(r.pop()) } return n } function A(r) { hr.push({ move: r, kings: { b: lr.b, w: lr.w }, turn: sr, castling: { b: pr.b, w: pr.w }, ep_square: cr, half_moves: vr, move_number: gr }) } function S(r) { var e = sr, n = N(e); if (A(r), ur[r.to] = ur[r.from], ur[r.from] = null, r.flags & er.EP_CAPTURE && (sr === Q ? ur[r.to - 16] = null : ur[r.to + 16] = null), r.flags & er.PROMOTION && (ur[r.to] = { type: r.promotion, color: e }), ur[r.to].type === F) { if (lr[ur[r.to].color] = r.to, r.flags & er.KSIDE_CASTLE) { var t = r.to - 1, o = r.to + 1; ur[t] = ur[o], ur[o] = null } else if (r.flags & er.QSIDE_CASTLE) { var t = r.to + 1, o = r.to - 2; ur[t] = ur[o], ur[o] = null } pr[e] = "" } if (pr[e]) for (var i = 0, f = ar[e].length; f > i; i++)if (r.from === ar[e][i].square && pr[e] & ar[e][i].flag) { pr[e] ^= ar[e][i].flag; break } if (pr[n]) for (var i = 0, f = ar[n].length; f > i; i++)if (r.to === ar[n][i].square && pr[n] & ar[n][i].flag) { pr[n] ^= ar[n][i].flag; break } cr = r.flags & er.BIG_PAWN ? "b" === sr ? r.to - 16 : r.to + 16 : x, r.piece === $ ? vr = 0 : r.flags & (er.CAPTURE | er.EP_CAPTURE) ? vr = 0 : vr++, sr === Q && gr++, sr = N(sr) } function C() { var r = hr.pop(); if (null == r) return null; var e = r.move; lr = r.kings, sr = r.turn, pr = r.castling, cr = r.ep_square, vr = r.half_moves, gr = r.move_number; var n = sr, t = N(sr); if (ur[e.from] = ur[e.to], ur[e.from].type = e.piece, ur[e.to] = null, e.flags & er.CAPTURE) ur[e.to] = { type: e.captured, color: t }; else if (e.flags & er.EP_CAPTURE) { var o; o = n === Q ? e.to - 16 : e.to + 16, ur[o] = { type: $, color: t } } if (e.flags & (er.KSIDE_CASTLE | er.QSIDE_CASTLE)) { var i, f; e.flags & er.KSIDE_CASTLE ? (i = e.to + 1, f = e.to - 1) : e.flags & er.QSIDE_CASTLE && (i = e.to - 2, f = e.to + 1), ur[i] = ur[f], ur[f] = null } return e } function T(r, e) { for (var n = c({ legal: !e }), t = r.from, o = r.to, i = r.piece, f = 0, a = 0, u = 0, l = 0, s = n.length; s > l; l++) { var p = n[l].from, v = n[l].to, g = n[l].piece; i === g && t !== p && o === v && (f++, w(t) === w(p) && a++, L(t) === L(p) && u++) } return f > 0 ? a > 0 && u > 0 ? R(t) : R(t).charAt(u > 0 ? 1 : 0) : "" } function I() { for (var r = "   +------------------------+\n", e = fr.a8; e <= fr.h1; e++) { if (0 === L(e) && (r += " " + "87654321"[w(e)] + " |"), null == ur[e]) r += " . "; else { var n = ur[e].type, t = ur[e].color, o = t === U ? n.toUpperCase() : n.toLowerCase(); r += " " + o + " " } e + 1 & 136 && (r += "|\n", e += 8) } return r += "   +------------------------+\n", r += "     a  b  c  d  e  f  g  h\n" } function P(r, e) { var n = g(r); if (e) { var t = n.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/); if (t) var o = t[1], i = t[2], f = t[3], a = t[4] } for (var u = c(), l = 0, s = u.length; s > l; l++) { if (n === g(v(u[l])) || e && n === g(v(u[l], !0))) return u[l]; if (!(!t || o && o.toLowerCase() != u[l].piece || fr[i] != u[l].from || fr[f] != u[l].to || a && a.toLowerCase() != u[l].promotion)) return u[l] } return null } function w(r) { return r >> 4 } function L(r) { return 15 & r } function R(r) { var e = L(r), n = w(r); return "abcdefgh".substring(e, e + 1) + "87654321".substring(n, n + 1) } function N(r) { return r === U ? Q : U } function O(r) { return -1 !== "0123456789".indexOf(r) } function k(r) { var e = q(r); e.san = v(e, !1), e.to = R(e.to), e.from = R(e.from); var n = ""; for (var t in er) er[t] & e.flags && (n += rr[t]); return e.flags = n, e } function q(r) { var e = r instanceof Array ? [] : {}; for (var n in r) "object" == typeof n ? e[n] = q(r[n]) : e[n] = r[n]; return e } function D(r) { return r.replace(/^\s+|\s+$/g, "") } function K(r) { for (var e = c({ legal: !1 }), n = 0, t = sr, o = 0, i = e.length; i > o; o++) { if (S(e[o]), !d(t)) if (r - 1 > 0) { var f = K(r - 1); n += f } else n++; C() } return n } var Q = "b", U = "w", x = -1, $ = "p", j = "n", B = "b", M = "r", G = "q", F = "k", W = "pnbrqkPNBRQK", H = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", Z = ["1-0", "0-1", "1/2-1/2", "*"], z = { b: [16, 32, 17, 15], w: [-16, -32, -17, -15] }, J = { n: [-18, -33, -31, -14, 18, 33, 31, 14], b: [-17, -15, 17, 15], r: [-16, 1, 16, -1], q: [-17, -16, -15, 1, 17, 16, 15, -1], k: [-17, -16, -15, 1, 17, 16, 15, -1] }, V = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20], X = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17], Y = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }, rr = { NORMAL: "n", CAPTURE: "c", BIG_PAWN: "b", EP_CAPTURE: "e", PROMOTION: "p", KSIDE_CASTLE: "k", QSIDE_CASTLE: "q" }, er = { NORMAL: 1, CAPTURE: 2, BIG_PAWN: 4, EP_CAPTURE: 8, PROMOTION: 16, KSIDE_CASTLE: 32, QSIDE_CASTLE: 64 }, nr = 7, tr = 6, or = 1, ir = 0, fr = { a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7, a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23, a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39, a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55, a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71, a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87, a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103, a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119 }, ar = { w: [{ square: fr.a1, flag: er.QSIDE_CASTLE }, { square: fr.h1, flag: er.KSIDE_CASTLE }], b: [{ square: fr.a8, flag: er.QSIDE_CASTLE }, { square: fr.h8, flag: er.KSIDE_CASTLE }] }, ur = new Array(128), lr = { w: x, b: x }, sr = U, pr = { w: 0, b: 0 }, cr = x, vr = 0, gr = 1, hr = [], dr = {}; return t("undefined" == typeof r ? H : r), { WHITE: U, BLACK: Q, PAWN: $, KNIGHT: j, BISHOP: B, ROOK: M, QUEEN: G, KING: F, SQUARES: function () { for (var r = [], e = fr.a8; e <= fr.h1; e++)136 & e ? e += 7 : r.push(R(e)); return r }(), FLAGS: rr, load: function (r) { return t(r) }, reset: function () { return n() }, moves: function (r) { for (var e = c(r), n = [], t = 0, o = e.length; o > t; t++)n.push("undefined" != typeof r && "verbose" in r && r.verbose ? k(e[t]) : v(e[t], !1)); return n }, in_check: function () { return E() }, in_checkmate: function () { return b() }, in_stalemate: function () { return _() }, in_draw: function () { return vr >= 100 || _() || y() || m() }, insufficient_material: function () { return y() }, in_threefold_repetition: function () { return m() }, game_over: function () { return vr >= 100 || b() || _() || y() || m() }, validate_fen: function (r) { return o(r) }, fen: function () { return i() }, pgn: function (r) { var e = "object" == typeof r && "string" == typeof r.newline_char ? r.newline_char : "\n", n = "object" == typeof r && "number" == typeof r.max_width ? r.max_width : 0, t = [], o = !1; for (var i in dr) t.push("[" + i + ' "' + dr[i] + '"]' + e), o = !0; o && hr.length && t.push(e); for (var f = []; hr.length > 0;)f.push(C()); for (var a = [], u = ""; f.length > 0;) { var l = f.pop(); hr.length || "b" !== l.color ? "w" === l.color && (u.length && a.push(u), u = gr + ".") : u = gr + ". ...", u = u + " " + v(l, !1), S(l) } if (u.length && a.push(u), "undefined" != typeof dr.Result && a.push(dr.Result), 0 === n) return t.join("") + a.join(" "); for (var s = 0, i = 0; i < a.length; i++)s + a[i].length > n && 0 !== i ? (" " === t[t.length - 1] && t.pop(), t.push(e), s = 0) : 0 !== i && (t.push(" "), s++), t.push(a[i]), s += a[i].length; return t.join("") }, load_pgn: function (r, e) { function o(r) { return r.replace(/\\/g, "\\") } function i(r) { for (var e in r) return !0; return !1 } function a(r, e) { for (var n = "object" == typeof e && "string" == typeof e.newline_char ? e.newline_char : "\r?\n", t = {}, i = r.split(new RegExp(o(n))), f = "", a = "", u = 0; u < i.length; u++)f = i[u].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, "$1"), a = i[u].replace(/^\[[A-Za-z]+\s"(.*)"\]$/, "$1"), D(f).length > 0 && (t[f] = a); return t } var u = "undefined" != typeof e && "sloppy" in e ? e.sloppy : !1, l = "object" == typeof e && "string" == typeof e.newline_char ? e.newline_char : "\r?\n", s = new RegExp("^(\\[(.|" + o(l) + ")*\\])(" + o(l) + ")*1.(" + o(l) + "|.)*$", "g"), p = r.replace(s, "$1"); "[" !== p[0] && (p = ""), n(); var c = a(p, e); for (var v in c) f([v, c[v]]); if ("1" === c.SetUp && !("FEN" in c && t(c.FEN))) return !1; var g = r.replace(p, "").replace(new RegExp(o(l), "g"), " "); g = g.replace(/(\{[^}]+\})+?/g, ""); for (var h = /(\([^\(\)]+\))+?/g; h.test(g);)g = g.replace(h, ""); g = g.replace(/\d+\.(\.\.)?/g, ""), g = g.replace(/\.\.\./g, ""), g = g.replace(/\$\d+/g, ""); var d = D(g).split(new RegExp(/\s+/)); d = d.join(",").replace(/,,+/g, ",").split(","); for (var E = "", b = 0; b < d.length - 1; b++) { if (E = P(d[b], u), null == E) return !1; S(E) } if (E = d[d.length - 1], Z.indexOf(E) > -1) i(dr) && "undefined" == typeof dr.Result && f(["Result", E]); else { if (E = P(E, u), null == E) return !1; S(E) } return !0 }, header: function () { return f(arguments) }, ascii: function () { return I() }, turn: function () { return sr }, move: function (r, e) { var n = "undefined" != typeof e && "sloppy" in e ? e.sloppy : !1, t = null; if ("string" == typeof r) t = P(r, n); else if ("object" == typeof r) for (var o = c(), i = 0, f = o.length; f > i; i++)if (!(r.from !== R(o[i].from) || r.to !== R(o[i].to) || "promotion" in o[i] && r.promotion !== o[i].promotion)) { t = o[i]; break } if (!t) return null; var a = k(t); return S(t), a }, undo: function () { var r = C(); return r ? k(r) : null }, clear: function () { return e() }, put: function (r, e) { return l(r, e) }, get: function (r) { return u(r) }, remove: function (r) { return s(r) }, perft: function (r) { return K(r) }, square_color: function (r) { if (r in fr) { var e = fr[r]; return (w(e) + L(e)) % 2 === 0 ? "light" : "dark" } return null }, history: function (r) { for (var e = [], n = [], t = ("undefined" != typeof r && "verbose" in r && r.verbose); hr.length > 0;)e.push(C()); for (; e.length > 0;) { var o = e.pop(); n.push(t ? k(o) : v(o)), S(o) } return n } } }; "undefined" != typeof exports && (exports.Chess = Chess), "undefined" != typeof define && define(function () { return Chess });
    </script>

    <!-- chessboard.js -->
    <script>
        const DEFAULT_POSITION_WHITE = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        const SLOW_ANIMATION = 600;
        const FAST_ANIMATION = 150;

        class ChessboardConfig {

            constructor(settings) {

                let defaults = {

                    // ---------------------- General
                    id_div: 'board',
                    position: 'start',
                    orientation: 'w',
                    mode: 'normal',
                    size: 'auto',

                    // ---------------------- Moves
                    draggable: true,
                    hints: true,
                    clickable: true,
                    movableColors: 'both',
                    moveHighlight: true,
                    overHighlight: true,
                    moveAnimation: 'ease',
                    moveTime: 'fast',

                    // ---------------------- Snapback
                    dropOffBoard: 'snapback',
                    snapbackTime: 'fast',
                    snapbackAnimation: 'ease',

                    // ---------------------- Fade
                    fadeTime: 'fast',
                    fadeAnimation: 'ease',

                    // ---------------------- Pieces
                    ratio: 0.9,
                    piecesPath: 'https://cdn.jsdelivr.net/npm/@alepot55/chessboardjs/default_pieces',

                    // ---------------------- Events
                    onMove: () => true,
                    onMoveEnd: () => true,
                    onChange: () => true,
                    onDragStart: () => true,
                    onDragMove: () => true,
                    onDrop: () => true,
                    onSnapbackEnd: () => true,

                    // ---------------------- Colors
                    whiteSquare: '#f0d9b5',
                    blackSquare: '#b58863',
                    highlight: 'yellow',
                    selectedSquareWhite: '#ababaa',
                    selectedSquareBlack: '#ababaa',
                    movedSquareWhite: '#f1f1a0',
                    movedSquareBlack: '#e9e981',
                    choiceSquare: 'white',
                    coverSquare: 'black',
                    hintColor: '#ababaa'
                };

                // ---------------------- General

                // id_div: string
                this.id_div = settings.id_div === undefined ? defaults.id_div : settings.id_div;

                // position: 'start', 'fen', {a1: 'wp', b2: 'bp', ...}, 'default'
                this.position = settings.position === undefined ? defaults.position : settings.position;

                // orientation: 'w', 'b'
                this.orientation = settings.orientation === undefined ? defaults.orientation : settings.orientation;

                // mode: 'normal', 'creative'
                this.mode = settings.mode === undefined ? defaults.mode : settings.mode;

                // deaggable: true, false
                this.draggable = settings.draggable === undefined ? defaults.draggable : settings.draggable;

                // dropOffBoard: 'snapback', 'trash'
                this.dropOffBoard = settings.dropOffBoard == undefined ? defaults.dropOffBoard : settings.dropOffBoard;

                // hints: true, false. se settings non contiene hints, allora hints = true
                this.hints = settings.hints === undefined ? defaults.hints : settings.hints;

                // clickable: true, false
                this.clickable = settings.clickable === undefined ? defaults.clickable : settings.clickable;

                // size: integer or 'auto'
                this.size = settings.size === undefined ? defaults.size : settings.size;

                // ---------------------- Moves

                // movableColors: 'white', 'black', 'both', 'none'
                this.movableColors = settings.movableColors === undefined ? defaults.movableColors : settings.movableColors;

                // moveHighlight: true, false
                this.moveHighlight = settings.moveHighlight === undefined ? defaults.moveHighlight : settings.moveHighlight;

                // overHighlight: true, false
                this.overHighlight = settings.overHighlight === undefined ? defaults.overHighlight : settings.overHighlight;

                // moveAnimation: 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'none'
                this.moveAnimation = settings.moveAnimation === undefined ? defaults.moveAnimation : settings.moveAnimation;

                // moveTime: integer, 'slow', 'fast'
                this.moveTime = settings.moveTime === undefined ? defaults.moveTime : settings.moveTime;

                // ---------------------- Snapback

                // snapbackTime: integer, 'slow', 'fast'f
                this.snapbackTime = settings.snapbackTime === undefined ? defaults.snapbackTime : settings.snapbackTime;

                // snapbackAnimation: 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'none'
                this.snapbackAnimation = settings.snapbackAnimation === undefined ? defaults.snapbackAnimation : settings.snapbackAnimation;

                // ---------------------- Fade

                // fadeTime: integer, 'slow', 'fast'
                this.fadeTime = settings.fadeTime === undefined ? defaults.fadeTime : settings.fadeTime;

                // fadeAnimation: 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'none'
                this.fadeAnimation = settings.fadeAnimation === undefined ? defaults.fadeAnimation : settings.fadeAnimation;

                // ---------------------- Pieces

                // ratio: integer
                settings.ratio === undefined ? this.setCSSProperty('pieceRatio', defaults.ratio) : this.setCSSProperty('pieceRatio', settings.ratio);

                // piecesPath: string
                this.piecesPath = settings.piecesPath === undefined ? defaults.piecesPath : settings.piecesPath;


                // ---------------------- Events

                // onMove: function(move)
                this.onMove = settings.onMove === undefined ? defaults.onMove : settings.onMove;

                // onMoveEnd: function(move)
                this.onMoveEnd = settings.onMoveEnd === undefined ? defaults.onMoveEnd : settings.onMoveEnd;

                // onChange: function(fen)
                this.onChange = settings.onChange === undefined ? defaults.onChange : settings.onChange;

                // onDragStart: function(from, piece)
                this.onDragStart = settings.onDragStart === undefined ? defaults.onDragStart : settings.onDragStart;

                // onDragMove: function(from, to, piece)
                this.onDragMove = settings.onDragMove === undefined ? defaults.onDragMove : settings.onDragMove;

                // onDrop: function(from, to, piece)
                this.onDrop = settings.onDrop === undefined ? defaults.onDrop : settings.onDrop;

                // onSnapbackEnd: function(from, piece)
                this.onSnapbackEnd = settings.onSnapbackEnd === undefined ? defaults.onSnapbackEnd : settings.onSnapbackEnd;

                // ---------------------- Colors

                // whiteSquare: string
                settings.whiteSquare === undefined ? this.setCSSProperty('whiteSquare', defaults.whiteSquare) : this.setCSSProperty('whiteSquare', settings.whiteSquare);

                // blackSquare: string
                settings.blackSquare === undefined ? this.setCSSProperty('blackSquare', defaults.blackSquare) : this.setCSSProperty('blackSquare', settings.blackSquare);

                // highlight: string
                settings.highlight === undefined ? this.setCSSProperty('highlightSquare', defaults.highlight) : this.setCSSProperty('highlightSquare', settings.highlight);

                // selectedSquareWhite: string
                settings.selectedSquareWhite === undefined ? this.setCSSProperty('selectedSquareWhite', defaults.selectedSquareWhite) : this.setCSSProperty('selectedSquareWhite', settings.selectedSquareWhite);

                // selectedSquareBlack: string
                settings.selectedSquareBlack === undefined ? this.setCSSProperty('selectedSquareBlack', defaults.selectedSquareBlack) : this.setCSSProperty('selectedSquareBlack', settings.selectedSquareBlack);

                // movedSquareWhite: string
                settings.movedSquareWhite === undefined ? this.setCSSProperty('movedSquareWhite', defaults.movedSquareWhite) : this.setCSSProperty('movedSquareWhite', settings.movedSquareWhite);

                // movedSquareBlack: string
                settings.movedSquareBlack === undefined ? this.setCSSProperty('movedSquareBlack', defaults.movedSquareBlack) : this.setCSSProperty('movedSquareBlack', settings.movedSquareBlack);

                // choiceSquare: string
                settings.choiceSquare === undefined ? this.setCSSProperty('choiceSquare', defaults.choiceSquare) : this.setCSSProperty('choiceSquare', settings.choiceSquare);

                // coverSquare: string
                settings.coverSquare === undefined ? this.setCSSProperty('coverSquare', defaults.coverSquare) : this.setCSSProperty('coverSquare', settings.coverSquare);

                // hintColor: string
                settings.hintColor === undefined ? this.setCSSProperty('hintColor', defaults.hintColor) : this.setCSSProperty('hintColor', settings.hintColor);

                // Configure modes

                if (this.mode === 'creative') {
                    this.onlyLegalMoves = false;
                    this.hints = false;
                } else if (this.mode === 'normal') {
                    this.onlyLegalMoves = true;
                }

                return this;
            }

            setCSSProperty(property, value) {
                document.documentElement.style.setProperty('--' + property, value);
            }

            setOrientation(orientation) {
                this.orientation = orientation;
                return this;
            }
        }

        class Chessboard {

            constructor(config) {

                this.config = new ChessboardConfig(config);

                this.pezzi = {};
                this.pieces = {};
                this.celle = {};
                this.squares = {};
                this.buildGame(this.config.position);
                this.initParams();
                this.buildBoard();
                this.updatePosition();
            }

            // Build

            buildGame(position) {
                if (position === 'start') {
                    this.game = new Chess();
                } else if (position === 'default') {
                    this.game = new Chess(DEFAULT_POSITION_WHITE);
                } else if (typeof position === 'string') {
                    this.game = new Chess(position);
                } else if (typeof position === 'object') {
                    let game = new Chess('start');
                    for (let square in position) {
                        game.put({ type: position[square][0], color: position[square][1] }, square);
                    }
                    this.game = game;
                } else {
                    throw new Error('Invalid position - ' + position + ' - must be a fen string, "start", "default" or a dictionary of pieces, like {a1: "wK", b2: "bQ", ...}');
                }
            }

            buildBoard() {
                this.board = document.getElementById(this.config.id_div);
                if (!this.board) {
                    throw new Error('Board id not found - ' + this.config.id_div + ' - must be a valid id of a div element');
                }
                this.resize(this.config.size);
                this.board.className = "board";
                this.buildSquares();
            }

            buildSquares() {
                this.squares = {};
                this.lastSquare = null;
                this.celle = {};
                this.pezzi = {};
                this.pieces = {};
                this.mosseIndietro = [];


                for (let row = 0; row < 8; row++) {

                    this.squares[row] = {};

                    for (let col = 0; col < 8; col++) {

                        // Imposta l'id della cella e crea un nuovo elemento div
                        let id = this.getSquareID(row, col)
                        let square = document.createElement("div");

                        this.celle[id] = square;
                        this.squares[row][col] = square;
                        square.id = id;
                        this.resetSquare(id);

                        this.board.appendChild(square);
                    }
                }

                this.addListeners();
            }

            initParams() {
                this.promoting = false;
                this.lastSquare = null;
                this.history = [];
                this.mosseIndietro = [];
                this.lastSquare = null;
            }

            resize(value) {
                if (value === 'auto') {
                    let size;
                    if (this.board.offsetWidth === 0) {
                        size = this.board.offsetHeight;
                    } else if (this.board.offsetHeight === 0) {
                        size = this.board.offsetWidth;
                    } else {
                        size = Math.min(this.board.offsetWidth, this.board.offsetHeight);
                    }
                    this.resize(size);
                } else if (typeof value !== 'number') {
                    throw new Error('Invalid value - ' + value + ' - must be a number or "auto"');
                } else {
                    document.documentElement.style.setProperty('--dimBoard', value + 'px');
                    this.updatePosition();
                }
            }

            destroy() {
                if (!this.board) throw new Error('Board not found');
                this.board.innerHTML = '';
                this.board.className = '';
            }


            // Pieces

            checkPiece(piece) {
                if (['p', 'r', 'n', 'b', 'q', 'k'].indexOf(piece[0]) === -1 || ['w', 'b'].indexOf(piece[1]) === -1) throw new Error('Invalid piece - ' + piece + ' - must be a valid piece like "pw" or "kb"');
            }

            getPiecePath(piece) {
                if (typeof this.config.piecesPath === 'string') return this.config.piecesPath + '/' + piece + '.svg';
                else return this.config.piecesPath(piece);
            }

            piece(square) {
                this.checkSquare(square);
                let piece = this.game.get(square);
                return piece ? piece['type'] + piece['color'] : null;
            }

            colorPiece(square) {
                let piece = this.piece(square);
                return piece ? piece[1] : null;
            }

            traslation(elem, from, to, duration) {

                let piece = elem.src.split('/').pop().split('.')[0];

                if (duration === 'none' || duration === 0) {
                    this.removePiece(from, piece, false);
                    this.insert(to, piece, false);
                    return;
                }
                else if (duration === 'slow') duration = SLOW_ANIMATION;
                else if (duration === 'fast') duration = FAST_ANIMATION;

                let startX, startY, endX, endY;

                if (from) {
                    startX = this.celle[from].getBoundingClientRect().left;
                    startY = this.celle[from].getBoundingClientRect().top;
                } else {
                    startX = elem.getBoundingClientRect().left - 4;
                    startY = elem.getBoundingClientRect().top - 4;
                }

                endX = this.celle[to].getBoundingClientRect().left;
                endY = this.celle[to].getBoundingClientRect().top;


                let x = endX - startX;
                let y = endY - startY;
                let startTime;
                let board = this;

                function translate(currentTime) {
                    if (!startTime) {
                        startTime = currentTime;
                    }

                    let timeElapsed = currentTime - startTime;
                    let t = timeElapsed / duration;
                    let progress = board.transitionTimingFunction(t, board.config.moveAnimation);
                    elem.style.transform = 'translate(' + (x * progress) + 'px, ' + (y * progress) + 'px)';

                    if (t < 1) {
                        requestAnimationFrame(translate);
                    } else {
                        if (from) board.removePiece(from, piece, false);
                        if (to) board.insert(to, board.piece(to), false);
                    }
                }

                requestAnimationFrame(translate);
            }

            translatePiece(piece, from, to, removeTo, animate) {

                if (!animate) {
                    this.removePiece(from, piece, false);
                    this.insert(to, piece, false);
                    return;
                };

                let elem = this.pieces[(piece, from)]['img'];

                if (removeTo) this.removePiece(to);

                return this.traslation(elem, from, to, this.config.moveTime);
            }

            snapbackPiece(square, piece, animate) {

                if (!animate || this.config.snapbackAnimation === 'none' || this.config.snapbackTime === 0) {
                    this.removePiece(square, piece, false);
                    this.insert(square, piece, false);
                    return;
                }

                let elem = this.pieces[(piece, square)]['img'];
                this.traslation(elem, null, square, this.config.snapbackTime);
            }

            fadeInPiece(square) {

                let duration = this.config.fadeTime;
                if (duration === 'slow') duration = SLOW_ANIMATION;
                else if (duration === 'fast') duration = FAST_ANIMATION;

                let elem = this.pezzi[square]['img'];

                let startTime;
                let board = this;

                function fadeIn(currentTime) {
                    if (!startTime) {
                        startTime = currentTime;
                    }
                    let timeElapsed = currentTime - startTime;
                    let t = timeElapsed / duration;
                    let progress = board.transitionTimingFunction(t, board.config.fadeAnimation);
                    elem.style.opacity = progress;

                    if (t < 1) {
                        requestAnimationFrame(fadeIn);
                    }
                }

                requestAnimationFrame(fadeIn);
            }

            fadeOutPiece(square, img, remove, animate) {

                let duration = this.config.fadeTime;
                if (duration === 'slow') duration = SLOW_ANIMATION;
                else if (duration === 'fast') duration = FAST_ANIMATION;

                if (!animate) {
                    if (remove) this.celle[square].removeChild(img);
                    else img.style.opacity = 0;
                    return;
                }

                let startTime;
                let board = this;

                function fadeOut(currentTime) {
                    if (!startTime) {
                        startTime = currentTime;
                    }
                    let timeElapsed = currentTime - startTime;
                    let t = timeElapsed / duration;
                    let progress = board.transitionTimingFunction(t, board.config.fadeAnimation);
                    img.style.opacity = 1 - progress;

                    if (t < 1) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        if (remove) board.celle[square].removeChild(img);
                    }
                }

                requestAnimationFrame(fadeOut);
            }

            removePiece(square, piece, fade = true) {

                if (!this.pezzi[square]) return null;
                piece = piece ? piece : this.pezzi[square]['piece'];
                if (this.pezzi[square]['piece'] !== piece) return null;

                if (fade) this.fadeOutPiece(square, this.pezzi[square]['img']);
                else this.celle[square].removeChild(this.pezzi[square]['img']);

                this.pezzi[square] = null;
                this.pieces[(piece, square)] = null;

                return piece;
            }

            insert(square, piece, fade = this.config.fadeAnimation) {

                if (fade === 'none' || fade === 0) fade = false;

                this.checkPiece(piece);
                this.checkSquare(square);

                if (!piece) return;
                this.removePiece(square, null, false);

                let img = document.createElement("img");
                img.className = "piece";
                img.src = this.getPiecePath(piece);
                img.style.opacity = fade ? 0 : 1;

                let board = this;
                img.onmousedown = function (event) {

                    if (!board.config.draggable) return;

                    let recent;
                    let from = square;
                    let to = square;
                    let moved = false;

                    if (!board.canMove(from)) return;

                    if (!board.config.clickable) board.lastSquare = null;
                    if (board.onClick(square)) return;

                    img.style.position = 'absolute';
                    img.style.zIndex = 15;

                    // Function to move the piece with the mouse pointer
                    function moveAt(pageX, pageY) {
                        if (!moved && !board.config.onDragStart(from, piece)) return;
                        moved = true;
                        img.style.left = pageX - img.offsetWidth / 2 + 'px';
                        img.style.top = pageY - img.offsetHeight / 2 + 'px';
                        return true;
                    }

                    function onMouseMove(event) {

                        // Bug fix for spamming the mousemove event
                        if (!piece) return;

                        if (!moveAt(event.pageX, event.pageY)) return;

                        // Find the square where the mouse is
                        let x = event.clientX - board.board.getBoundingClientRect().left;
                        let y = event.clientY - board.board.getBoundingClientRect().top;

                        let col = Math.floor(x / (board.board.offsetWidth / 8));
                        let row = Math.floor(y / (board.board.offsetHeight / 8));
                        if (x < 0 || x > board.board.offsetWidth || y < 0 || y > board.board.offsetHeight) to = null;
                        else to = board.getSquareID(row, col);
                        board.config.onDragMove(from, to, piece);

                        if (to !== recent) {
                            board.highlight(to);
                            board.dehighlight(recent);
                            recent = to;
                        }
                    }
                    document.addEventListener('mousemove', onMouseMove);

                    // Drop the piece and remove the event listener
                    img.onmouseup = function () {
                        board.dehighlight(recent);
                        document.removeEventListener('mousemove', onMouseMove);
                        img.onmouseup = null;
                        let drop = board.config.onDrop(from, to, piece);

                        if ((board.config.dropOffBoard === 'trash' || drop === 'trash') && !to) {
                            board.unmoveAllSquares();
                            board.dehintAllSquares();
                            board.deselect(from);
                            board.remove(from);
                        } else if (moved && (!board.onClick(to, false) || drop === 'snapback')) {
                            board.snapbackPiece(from, piece, !board.promoting);
                            board.config.onSnapbackEnd(from, piece);
                        }
                    };

                };

                // Prevent the image from being dragged
                img.ondragstart = function () {
                    return false;
                };

                this.pezzi[square] = { 'img': img, 'piece': piece };
                this.pieces[(piece, square)] = { 'img': img };
                this.celle[square].appendChild(img);

                if (fade) this.fadeInPiece(square);
                else img.style.opacity = 1;
                return img;
            }

            updatePieces(animation) {

                let ok = {};
                let escaping = {};
                let canEscape = {};
                let toTranslate = [];

                for (let square in this.celle) {
                    ok[square] = false;
                    escaping[square] = false;
                    canEscape[square] = this.pezzi[square] && this.piece(square) !== this.pezzi[square]['piece'];
                }


                for (let square in this.celle) {

                    let pieceNew = this.piece(square);
                    let pieceOld = this.pezzi[square] ? this.pezzi[square]['piece'] : null;

                    if (pieceOld !== pieceNew && !ok[square]) {


                        for (let from in this.pezzi) {

                            let coming = this.pezzi[from] ? this.pezzi[from]['piece'] : null;

                            if (coming && canEscape[from] && !ok[square] && from !== square && coming === pieceNew && !this.isPiece(pieceNew, from)) {

                                // check for en passant
                                let lastMove = this.lastMove();
                                if (!pieceOld && lastMove && lastMove['captured'] === 'p') {
                                    let captured = 'p' + (lastMove['color'] === 'w' ? 'b' : 'w');
                                    this.removePiece(square[0] + from[1], captured);
                                }

                                toTranslate.push([coming, from, square]);

                                if (!this.piece(from)) ok[from] = true;
                                escaping[from] = true;
                                canEscape[from] = false;

                                ok[square] = true;

                                break;
                            }
                        }
                    }
                }

                for (let [piece, from, to] of toTranslate) {
                    this.translatePiece(piece, from, to, !escaping[to], animation);
                }

                for (let square in this.celle) {

                    let pieceNew = this.piece(square);
                    let pieceOld = this.pezzi[square] ? this.pezzi[square]['piece'] : null;

                    if (pieceOld !== pieceNew && !ok[square]) {

                        if (!ok[square]) {
                            // check for promotion
                            let lastMove = this.lastMove();
                            if (lastMove && lastMove['promotion']) {
                                if (lastMove['to'] === square) {
                                    let piece = lastMove['promotion'] + lastMove['color'];
                                    this.translatePiece(piece, lastMove['from'], square, true, animation);
                                    ok[lastMove['from']] = true;
                                }
                            } else {
                                this.removePiece(square);
                                if (pieceNew) this.insert(square, pieceNew);
                            }
                        }
                    }
                }

                this.config.onChange(this.game.fen());
            }

            opponentPiece(square) {
                let piece = this.piece(square);
                return piece && piece[1] !== this.config.orientation;
            }

            playerPiece(square) {
                let piece = this.piece(square);
                return piece && piece[1] === this.config.orientation;
            }

            isPiece(piece, square) {
                return this.piece(square) === piece;
            }

            remove(square, animation = true) {
                this.checkSquare(square);
                this.game.remove(square);
                this.removePiece(square, null, animation);
            }


            // Listeners

            addListeners() {
                if (this.mosseIndietro.length > 0) return;
                for (let square in this.celle) {
                    let elem = this.celle[square];
                    elem.addEventListener("mouseover", () => {
                        if (!this.lastSquare) this.hintMoves(elem.id);
                    });
                    elem.addEventListener("mouseout", () => {
                        if (!this.lastSquare) this.dehintMoves(elem.id);
                    });
                    elem.addEventListener("click", () => {
                        if (this.config.clickable && (!this.pezzi[elem.id] || this.config.onlyLegalMoves)) this.onClick(elem.id)
                    });
                    elem.addEventListener("touch", () => {
                        if (this.config.clickable) this.onClick(elem.id)
                    });
                }
            }

            onClick(square, animation = this.config.moveAnimation) {

                if (!square || square === this.lastSquare) return;

                if (animation === 'none') animation = false;

                if (this.promoting) {
                    this.depromoteAllSquares();
                    this.removeAllCovers();
                    this.promoting = false;
                    if (square.length === 2) this.lastSquare = null;
                }

                let from = this.lastSquare;
                this.lastSquare = null;
                let move = from + square;

                if (from) {
                    this.deselect(from);
                    this.dehintAllSquares();
                } else if (!this.canMove(square)) return;


                if (from && this.canMove(from) && (!this.canMove(square) || !this.config.onlyLegalMoves)) {

                    if (this.config.onlyLegalMoves && !this.legalMove(move)) return;
                    if (move.length == 4 && this.promote(move)) return;

                    if (this.config.onMove(move)) this.move(move, animation);
                    else return;

                    return true;

                } else if (this.canMove(square)) {

                    this.select(square);
                    this.hintMoves(square);
                    this.lastSquare = square;
                }
            }

            // Hint

            hint(square) {
                this.checkSquare(square);
                if (!this.config.hints || !this.celle[square]) return;

                let hint = document.createElement("div");
                hint.className = "hint";

                if (this.colorPiece(square) && this.colorPiece(square) !== this.turn()) hint.className += " catchable";

                this.celle[square].appendChild(hint);

            }

            hintMoves(square) {
                if (!this.canMove(square)) return;
                let mosse = this.game.moves({ square: square, verbose: true });
                for (let mossa of mosse) {
                    if (mossa['to'].length === 2) this.hint(mossa['to']);
                }
            }

            dehintMoves(square) {
                let mosse = this.game.moves({ square: square, verbose: true });
                for (let mossa of mosse) {
                    if (mossa['to'].length === 2) this.dehint(mossa['to']);
                }
            }

            dehint(square) {
                if (square.length !== 2) return;
                if (this.config.hints) {
                    let cella = this.celle[square];
                    if (!cella) return;
                    let figli = cella.childNodes;

                    for (let i = figli.length - 1; i >= 0; i--) {
                        if (figli[i].className.includes('hint')) {
                            cella.removeChild(figli[i]);
                        }
                    }
                }
            }

            dehintAllSquares() {
                for (let casella in this.celle) {
                    this.dehint(casella);
                }
            }

            // Select

            select(square) {
                this.checkSquare(square);
                if (!this.config.clickable) return;
                let elem = this.celle[square];
                if (elem.className.includes('selectedSquareWhite') || elem.className.includes('selectedSquareBlack')) return;
                if (this.isWhiteSquare(square)) elem.className += ' selectedSquareWhite';
                else elem.className += ' selectedSquareBlack';
            }

            deselect(square) {
                this.checkSquare(square);
                let elem = this.celle[square];
                if (this.isWhiteSquare(square)) elem.className = elem.className.replace(' selectedSquareWhite', '');
                else elem.className = elem.className.replace(' selectedSquareBlack', '');
            }

            deselectAllSquares() {
                for (let casella in this.celle) {
                    this.deselect(casella);
                }
            }

            // Moves

            checkMove(move) {
                if (move.length < 4 || move.length > 5) throw new Error('Invalid move - ' + move + ' - must be a valid move like "e2e4" or "e7e8q"');
                let from = move.slice(0, 2);
                let to = move.slice(2, 4);
                let prom = move.length === 5 ? move[4] : null;
                this.checkSquare(from);
                this.checkSquare(to);
                if (prom && ['q', 'r', 'n', 'b'].indexOf(prom) === -1) throw new Error('Invalid promotion - ' + prom + ' - must be a valid piece like "q", "r", "n" or "b"');
            }

            canMove(square) {
                if (!this.piece(square)) return false;
                if (this.config.movableColors === 'none') return false;
                if (this.config.movableColors === 'w' && this.colorPiece(square) === 'b') return false;
                if (this.config.movableColors === 'b' && this.colorPiece(square) === 'w') return false;
                if (!this.config.onlyLegalMoves) return true;
                if (this.colorPiece(square) !== this.turn()) return false;
                return true;
            }

            move(move, animation) {

                if (!this.canMove(move.slice(0, 2))) return false;

                this.checkMove(move);

                if (!this.config.onlyLegalMoves) {
                    let piece = this.piece(move.slice(0, 2));
                    this.game.remove(move.slice(0, 2));
                    this.game.remove(move.slice(2, 4));
                    this.game.put({ type: move[4] ? move[4] : piece[0], color: piece[1] }, move.slice(2, 4));
                    return this.updatePosition(false, false);
                }

                this.unmoveAllSquares();

                move = this.game.move({
                    from: move.slice(0, 2),
                    to: move.slice(2, 4),
                    promotion: move.length === 5 ? move[4] : null
                });


                this.history.push(move);

                this.updatePosition(false, animation);

                this.moved(move['to']);
                this.moved(move['from']);

                this.dehintAllSquares();

                this.config.onMoveEnd(move['from'] + move['to'] + (move['promotion'] ? move['promotion'] : ''));

                return true;


            }

            moved(square) {
                this.checkSquare(square);
                if (!this.config.moveHighlight) return;
                let elem = this.celle[square];
                if (elem.className.includes(' movedSquareWhite') || elem.className.includes(' movedSquareBlack')) return;
                if (this.isWhiteSquare(square)) elem.className += ' movedSquareWhite';
                else elem.className += ' movedSquareBlack';
            }

            unmoved(square) {
                this.checkSquare(square);
                if (!this.config.moveHighlight) return;
                let elem = this.celle[square];
                if (this.isWhiteSquare(square)) elem.className = elem.className.replace(' movedSquareWhite', '');
                else elem.className = elem.className.replace(' movedSquareBlack', '');
            }

            unmoveAllSquares() {
                for (let casella in this.celle) {
                    this.unmoved(casella);
                }
                return;
            }

            legalMove(mossa) {
                let legalMoves = this.legalMoves(mossa.slice(0, 2));
                for (let i in legalMoves) {
                    if (legalMoves[i]['to'] === mossa.slice(2, 4) && (mossa.length === 4 || mossa[4] === legalMoves[i]['promotion'])) return true;
                }

                return false;
            }

            legalMoves(from = null, verb = true) {
                if (from) this.checkSquare(from);
                else return this.game.moves({ verbose: verb });
                return this.game.moves({ square: from, verbose: verb });
            }

            lastMove() {
                return this.history[this.history.length - 1];
            }

            getHistory() {
                return this.history;
            }

            // State

            isGameOver() {
                if (this.game.game_over()) {
                    if (this.game.in_checkmate()) return this.game.turn() === 'w' ? 'b' : 'w';
                    return 'd';
                }
                return null;
            }

            turn() {
                return this.game.turn();
            }

            getOrientation() {
                return this.config.orientation;
            }

            orientation(color) {
                if ((color === 'w' || color === 'b') && color !== this.config.orientation) this.flip();
            }

            // Position

            chageFenTurn(fen, color) {
                let parts = fen.split(' ');
                parts[1] = color;
                return parts.join(' ');
            }

            position(position, color = null) {
                this.initParams();
                this.dehintAllSquares();
                this.deselectAllSquares();
                this.unmoveAllSquares();
                this.buildGame(position);
                position = this.game.fen();
                if (!color) color = position.split(' ')[1];
                let change_color = this.config.orientation !== color;
                this.config.setOrientation(color);
                this.game = new Chess(position);
                this.updatePosition(change_color);
            }

            flip() {
                let position = this.game.fen();
                this.position(position, this.config.orientation === 'w' ? 'b' : 'w');
            }

            playerTurn() { // Restituisce true se è il turno del giocatore
                return this.config.orientation === this.game.turn();
            }

            isWhiteSquare(square) {
                this.checkSquare(square);
                let letters = 'abcdefgh';
                return (letters.indexOf(square[0]) + parseInt(square[1])) % 2 === 0;
            }

            isWhiteOriented() {
                return this.config.orientation === 'w';
            }

            updatePosition(change_color = false, animation = this.config.moveAnimation) {
                if (change_color) {
                    this.renameSquares();
                }
                this.updatePieces(animation);
            }

            renameSquares() {
                let new_celle = {};
                let new_pezzi = {};
                let new_pieces = {};
                for (let elem in this.celle) {
                    let square = this.celle[elem];
                    let id = square.id;
                    let [row, col] = this.getSquareCoord(id);
                    let new_row = 7 - row;
                    let new_col = 7 - col;
                    square.id = this.getSquareID(new_row, new_col);
                    new_celle[square.id] = square;
                    if (this.pezzi[id]) {
                        new_pezzi[square.id] = this.pezzi[id];
                        new_pieces[(this.pezzi[id]['piece'], square.id)] = this.pieces[(this.pezzi[id]['piece'], id)];
                    }

                }
                this.celle = new_celle;
                this.pezzi = new_pezzi;
                this.pieces = new_pieces;
            }

            getPosition(mode) {
                if (!mode || mode === 'fen') return this.game.fen();
                let dict = {};
                for (let square in this.celle) {
                    let piece = this.piece(square);
                    if (piece) dict[square] = piece;
                }
                return dict;
            }

            // Squares

            checkSquare(square) {
                if (!square) return;
                if (['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(square[0]) === -1 || ['1', '2', '3', '4', '5', '6', '7', '8'].indexOf(square[1]) === -1) throw new Error('Invalid square - ' + square + ' - must be a valid square like "a1" or "h8"');
            }

            getSquareCoord(coord) {
                let letters = 'abcdefgh';
                if (this.isWhiteOriented()) {
                    return [8 - parseInt(coord[1]), letters.indexOf(coord[0])];
                }
                return [parseInt(coord[1]) - 1, 7 - letters.indexOf(coord[0])];
            }

            resetSquare(square) {
                let elem = this.celle[square];
                elem.className = 'square ' + (this.isWhiteSquare(square) ? 'whiteSquare' : 'blackSquare');
            }

            getSquareID(row, col) {
                row = parseInt(row);
                col = parseInt(col);
                if (this.isWhiteOriented()) {
                    row = 8 - row;
                    col = col + 1;
                } else {
                    row = row + 1;
                    col = 8 - col;
                }
                let letters = 'abcdefgh';
                let letter = letters[col - 1];
                return letter + row;
            }

            removeSquares() { // Rimuove le caselle dalla Chessboard
                for (let casella in this.celle) {
                    this.board.removeChild(this.celle[casella]);
                }
                this.celle = {};
            }

            clear(animation = true) {
                this.game.clear();
                this.updatePosition(null, animation);
            }

            // Highlight

            highlight(square) {
                if (!square || !this.celle[square] || !this.config.overHighlight) return;
                let elem = this.celle[square];
                if (elem.className.includes('highlighted')) return;
                elem.className += ' highlighted';
            }

            dehighlight(square) {
                if (!square || !this.celle[square] || !this.config.overHighlight) return;
                this.checkSquare(square);
                let elem = this.celle[square];
                elem.className = elem.className.replace(' highlighted', '');
            }


            // Promotion

            coverSquare(square) {
                let cover = document.createElement("div");
                cover.className = "square cover";
                this.celle[square].appendChild(cover);
            }

            removeCover(square) {
                let elem = this.celle[square];
                let figli = elem.childNodes;

                for (let i = figli.length - 1; i >= 0; i--) {
                    if (figli[i].className.includes('cover')) {
                        elem.removeChild(figli[i]);
                    }
                }
            }

            removeAllCovers() {
                for (let casella in this.celle) {
                    this.removeCover(casella);
                }
            }

            promoteSquare(square, piece) {
                let choice = document.createElement("div");
                choice.className = "square choice";

                let img = document.createElement("img");
                img.className = "piece choicable";
                img.src = this.getPiecePath(piece);
                choice.appendChild(img);

                this.celle[square].appendChild(choice);

                return choice;
            }

            depromoteSquare(square) {
                let elem = this.celle[square];
                let figli = elem.childNodes;

                for (let i = figli.length - 1; i >= 0; i--) {
                    if (figli[i].className.includes('choice')) {
                        elem.removeChild(figli[i]);
                    }
                }
            }

            depromoteAllSquares() {
                for (let casella in this.celle) {
                    this.depromoteSquare(casella);
                }
            }

            promote(mossa) {

                if (!this.config.onlyLegalMoves) return false;

                let to = mossa.slice(2, 4);
                let from = mossa.slice(0, 2);
                let pezzo = this.game.get(from);
                let [row, col] = this.getSquareCoord(to);
                let choices = ['q', 'r', 'b', 'n']

                if (pezzo['type'] !== 'p' || !(row === 0 || row === 7)) return false;

                this.promoting = true;

                for (let casella in this.celle) {
                    let [rowCurr, colCurr] = this.getSquareCoord(casella);

                    if (col === colCurr && Math.abs(row - rowCurr) <= 3) {

                        let choice = this.promoteSquare(casella, choices[Math.abs(row - rowCurr)] + pezzo['color']);
                        choice.addEventListener('click', () => {
                            this.onClick(to + choices[Math.abs(row - rowCurr)]);
                        });

                    } else {
                        this.coverSquare(casella);
                    }
                }

                this.lastSquare = from;

                return true;
            }

            // Other

            transitionTimingFunction(x, type = 'ease') {
                switch (type) {
                    case 'linear':
                        return x;
                    case 'ease':
                        return (x ** 2) * (3 - 2 * x);
                    case 'ease-in':
                        return x ** 2;
                    case 'ease-out':
                        return -1 * (x - 1) ** 2 + 1;
                    case 'ease-in-out':
                        return (x < 0.5) ? 2 * x ** 2 : 4 * x - 2 * x ** 2 - 1;
                }
            }
        }
    </script>

    <script>

        var ruyLopezFEN = 'r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3';
        var randomPositionFEN = 'r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R5K1 w - - 0 19';

        var buttonClass = "button-4";

        var board = new Chessboard({ id_div: "board" });

        var buttonContainer = document.getElementById("buttonContainer");
        var textContainer = document.getElementById("textContainer");
        var explanations = document.getElementById("explanations");
        var title = document.getElementById("title");
        var codeContainer = document.getElementById("codeContainer");

        var configs = {

            // Basics
            1: {
                id_div: "board",
                position: "start", // optional
            },
            2: {
                id_div: "board",
                position: randomPositionFEN,
            },
            3: {
                id_div: "board",
                position: {
                    'd5': 'pw',
                    'e5': 'kw',
                    'e8': 'kb',
                }
            },
            4: {
                id_div: "board",
                position: randomPositionFEN,
                orientation: "b",
            },
            5: {
                id_div: "board",
                size: 500, // modificare div board
            },

            // Configurations
            6: {
                id_div: "board",
                draggable: false,
            },
            7: {
                id_div: "board",
                clickable: false,
            },
            8: {
                id_div: "board",
                mode: "creative",
            },
            9: {
                id_div: "board",
                movableColors: "w",
            },
            10: {
                id_div: "board",
                moveAnimation: 'none',
                snapbackAnimation: 'none',
                fadeAnimation: 'none',
            },
            11: {
                id_div: "board",
                piecesPath: 'https://cdn.jsdelivr.net/npm/@alepot55/chessboardjs/alepot_theme',
                ratio: 0.75,
            },
            12: {
                id_div: "board",
                whiteSquare: '#e7edf9', blackSquare: '#b6c1d8',
                selectedSquareWhite: '#b5a6fc', selectedSquareBlack: '#a192ed',
                movedSquareWhite: '#b5a6fc', movedSquareBlack: '#a192ed',
                choiceSquare: 'white',
                coverSquare: '#343c4c',
                highlight: 'purple',
                hintColor: '#b5a6fc',
            },

            // Methods
            13: {
                id_div: "board",
            },
            14: {
                id_div: "board",
            },
            15: {
                id_div: "board",
            },
            16: {
                id_div: "board",
                position: "r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3",
            },
            17: {
                id_div: "board",
            },
            18: {
                id_div: "board",
            },
            19: {
                id_div: "board",
            },
            20: {
                id_div: "board",
            },

            // Events
            21: {
                id_div: "board",
                onMove: (move) => {
                    textContainer.innerHTML = 'Move: ' + move;
                    return true;
                },
            },
            22: {
                id_div: "board",
                onMoveEnd: (move) => {
                    textContainer.innerHTML = 'Move end: ' + move;
                },
            },
            23: {
                id_div: "board",
                onDragStart: (from, piece) => {
                    textContainer.innerHTML = 'Drag start: ' + from + ' ' + piece;
                    return true;
                },
            },
            24: {
                id_div: "board",
                onDragMove: (from, to, piece) => {
                    textContainer.innerHTML = 'Drag move: ' + from + ' ' + to + ' ' + piece;
                },
            },
            25: {
                id_div: "board",
                onDrop: (from, to, piece) => {
                    textContainer.innerHTML = 'Drop: ' + from + ' ' + to + ' ' + piece;
                },
            },
            26: {
                id_div: "board",
                onSnapbackEnd: (from, piece) => {
                    textContainer.innerHTML = 'Snapback end: ' + from + ' ' + piece;
                },
            },
            27: {
                id_div: "board",
                onChange: (fen) => {
                    textContainer.innerHTML = 'Changed: ' + fen;
                },
            },
        };

        var buttons = {

            // Basics
            1: {
            },
            2: {
            },
            3: {
            },
            4: {
                'Flip': () => board.flip(),
                'Orientation': () => textContainer.innerHTML = 'Orientation: ' + board.getOrientation(),
                'White orientation': () => board.orientation('w'),
            },
            5: {
            },

            // Configurations
            6: {
            },
            7: {
            },
            8: {
            },
            9: {
            },
            10: {
            },
            11: {
            },
            12: {
            },

            // Methods
            13: {
                'Get FEN': () => {
                    textContainer.innerHTML = 'FEN: ' + board.getPosition();
                },
                'Get dictionary': () => {
                    let dict = board.getPosition('dict');
                    textContainer.innerHTML = 'Dictionary: <br>'
                    for (let key in dict) {
                        textContainer.innerHTML += key + ': ' + dict[key] + '<br>';
                    }

                },
                'Ruy Lopez': () => {
                    board.position(ruyLopezFEN);
                    textContainer.innerHTML = 'Ruy Lopez';
                },
                'End game': () => {
                    board.position({
                        'd5': 'pw',
                        'e5': 'kw',
                        'e8': 'kb',
                    }, 'b');
                    textContainer.innerHTML = 'End game';
                },
                'Start position': () => {
                    board.position('start');
                    textContainer.innerHTML = 'Start position';
                },
            },
            14: {
                'a2 - a3': () => {
                    board.move('a2a3');
                    textContainer.innerHTML = 'a2 - a3';
                },
                'b7 - b5': () => {
                    board.move('b7b5');
                    textContainer.innerHTML = 'b7 - b5';
                },
                'Start position': () => {
                    board.position('start');
                    textContainer.innerHTML = 'Start position';
                },
                'Legal moves': () => {
                    let moves = board.legalMoves();
                    textContainer.innerHTML = 'Legal moves: <br>'
                    for (let i = 0; i < moves.length; i++) {
                        textContainer.innerHTML += moves[i]['from'] + ' - ' + moves[i]['to'] + '<br>';
                    }
                },
                'History': () => {
                    let history = board.getHistory();
                    textContainer.innerHTML = 'History: <br>'
                    for (let i = 0; i < history.length; i++) {
                        textContainer.innerHTML += 'move: ' + history[i]['from'] + ' -> ' + history[i]['to'] + ' === piece: ' + history[i]['piece'] + history[i]['color'] + '<br>';
                    };
                },
                'Set d5 moved': () => {
                    board.moved('d5');
                    textContainer.innerHTML = 'Set d5 moved';
                },
                'Set d5 unmoved': () => {
                    board.unmoved('d5');
                    textContainer.innerHTML = 'Set d5 unmoved';
                },
            },
            15: {
                'State': () => {
                    let s = board.isGameOver();
                    textContainer.innerHTML = 'State: ' + (s === 'w' ? 'White wins' : s === 'b' ? 'Black wins' : s === 'd' ? 'Draw' : 'Not over');
                },
                'Turn': () => {
                    let t = board.turn() === 'w' ? 'White' : 'Black';
                    textContainer.innerHTML = 'Turn: ' + t + ' to move';
                },
            },
            16: {
                'Reset': () => {
                    board.clear();
                    textContainer.innerHTML = 'Reset';
                },
                'Ruy Lopez': () => {
                    board.position(ruyLopezFEN);
                    textContainer.innerHTML = 'Ruy Lopez';
                }
            },
            17: {
                'Destroy': () => {
                    board.destroy();
                    textContainer.innerHTML = 'Destroy';
                },
                'Set board': () => {
                    board.destroy();
                    board = new Chessboard('board');
                    textContainer.innerHTML = 'Set board';
                },
            },
            18: {
                'Hint on d5': () => {
                    board.hint('d5');
                    textContainer.innerHTML = 'Hint on d5';
                },
                'Remove hint': () => {
                    board.dehint('d5');
                    textContainer.innerHTML = 'Remove hint';
                },
            },
            19: {
                'Select d5': () => {
                    board.select('d5');
                    textContainer.innerHTML = 'Select d5';
                },
                'Unselect': () => {
                    board.deselect('d5');
                    textContainer.innerHTML = 'Unselect';
                },
            },
            20: {
                'Highlight d5': () => {
                    board.highlight('d5');
                    textContainer.innerHTML = 'Highlight d5';
                },
                'Remove highlight': () => {
                    board.dehighlight('d5');
                    textContainer.innerHTML = 'Remove highlight';
                },
            },


            // Events
            21: {},
            22: {},
            23: {},
            24: {},
            25: {},
            26: {},
            27: {},


        }

        var texts = {
            1: 'The start position is the initial position of the pieces on the board. It can be set with the position property, but it already is the default position.',
            2: 'The position can be set with a FEN string. The FEN string is a notation that describes the position of the pieces on the board. The FEN string is composed of 6 parts: piece placement, active color, castling availability, en passant target square, halfmove clock, and fullmove number.',
            3: 'The position can also be set with an object. The object has the keys as the squares and the values as the pieces. The keys are the squares in algebraic notation and the values are the pieces in the format piece + color. The color is w for white and b for black. The piece is the first letter of the piece name in lowercase.',
            4: 'The orientation can be set with the orientation property. The orientation is the side of the board that is facing the player. The orientation can be set to white or black. <br> <br> The .flip() method can be used to change the orientation and the .getOrientation() method can be used to get the current orientation. Also, the orientation can be set to a specific color with the .orientation() method.',
            5: 'The size of the board can be set with the size property. The size is the width of the board in pixels. The size can be set to any positive number. The default size is 400 pixels.',
            6: 'The draggable property can be set to false to disable the dragging of the pieces. The pieces can still be moved with the .move() method.',
            7: 'The clickable property can be set to false to disable the clicking of the squares. The squares can still be moved by dragging the pieces.',
            8: 'The mode property can be set to creative to enable the creative mode. The creative mode allows the player to move the pieces freely without any restrictions, so the moves do not have to be legal and the hints are not shown. The creative mode is useful for learning and exploring the game. \n The normal mode is the default mode, where the moves have to be legal and the hints can be shown.',
            9: 'The movableColors property can be set to w to allow only the white pieces to be moved. The movableColors property can be set to b to allow only the black pieces to be moved. The movableColors property can be set to both to allow both the white and black pieces to be moved. The movableColors property can be set to none to disable the moving of the pieces.',
            10: 'The moveAnimation property can be set to none to disable the move animation. The snapbackAnimation property can be set to none to disable the snapback animation. The fadeAnimation property can be set to none to disable the fade animation. <br> <br> The animations can be set to slow, fast, or any integer number to set the duration of the animations in milliseconds.',
            11: 'The piecesPath property can be set to the path of the folder that contains the piece images. <br> <br> The ratio property can be set to a number between 0 and 1 to set the size of the pieces relative to the size of the squares. The default ratio is 0.75. The above piece theme can be used by setting the piecesPath property to alepot_theme',
            12: 'The whiteSquare and blackSquare properties can be set to the colors of the squares. The selectedSquareWhite and selectedSquareBlack properties can be set to the colors of the selected squares. <br> <br> The movedSquareWhite and movedSquareBlack properties can be set to the colors of the moved squares. The choiceSquare property can be set to white or black to set the color of the choice square. <br> <br> The coverSquare property can be set to the color of the cover square.<br> <br>  The highlight property can be set to the color of the highlighted squares, when a piece is dragged over them. <br> <br> The hintColor property can be set to the color of the hint squares.',
            13: 'The position can be set with the position() method. The position() method takes a FEN string as an argument. The position can be set to the start position with the position("start") method. For both the Ruy Lopez and the Italian Game, the position can be set with the corresponding FEN string.',
            14: 'The moves can be made with the move() method. The move() method takes a move in algebraic notation as an argument and makes the move if it is legal (in the normal mode) or if the creative mode is enabled. <br> <br> The method .legalMoves() returns an array of the legal moves. <br> <br> The method .getHistory() returns an array of the moves that have been made since the last .position() method call. <br> <br> The method .moved() marks a square as moved and the method .unmoved() marks a square as unmoved.',
            15: 'The state of the game can be checked with the isGameOver() method. The method returns "w" if white wins, "b" if black wins, "d" if the game is a draw, and null if the game is not over. The turn of the player to move can be checked with the turn() method.',
            16: 'The board can be reset to the default position with the clear() method. In this position there are no pieces on the board.',
            17: 'The board can be destroyed with the destroy() method. The board is removed from the DOM and all the event listeners are removed. The board can be set again with the new Chessboard() constructor.',
            18: 'The hint() method can be used to show a hint on a square. The dehint() method can be used to remove the hint from a square.',
            19: 'The select() method can be used to select a square. The deselect() method can be used to unselect a square.',
            20: 'The highlight() method can be used to highlight a square. The dehighlight() method can be used to remove the highlight from a square.',
            21: 'The onMove event is triggered when a move is made. The event handler takes the move as an argument and returns true to allow the move or false to prevent the move.',
            22: 'The onMoveEnd event is triggered when a move is completed. The event handler takes the move as an argument.',
            23: 'The onDragStart event is triggered when a piece is dragged. The event handler takes the from square and the piece as arguments and returns true to allow the drag or false to prevent the drag.',
            24: 'The onDragMove event is triggered when a piece is dragged to a square. The event handler takes the from square, the to square, and the piece as arguments.',
            25: 'The onDrop event is triggered when a piece is dropped on a square. The event handler takes the from square, the to square, and the piece as arguments.',
            26: 'The onSnapbackEnd event is triggered when a piece is snapped back to its original position. The event handler takes the from square and the piece as arguments.',
            27: 'The onChange event is triggered when the position of the pieces on the board changes. The event handler takes the FEN string of the new position as an argument.',

        }

        function active(i) {
            var coll = document.getElementsByClassName("collapsible");
            coll[i].classList.toggle("active");
            var content = coll[i].nextElementSibling;
            if (content.style.maxHeight) {
                content.style.maxHeight = null;
            } else {
                content.style.maxHeight = content.scrollHeight + "px";
            }
        }

        function getCode(item) {
            // Reutns the code for the html and js

            let total = '';

            // HTML
            let html = `HTML: \n<div id="board"></div> \n`;
            // per ogni bottone di item, mostra il codice del bottone
            for (let key in buttons[item]) {
                let fname = key.replace(/ /g, '');
                html += `<button onclick="${fname}()"> ${key} </button> \n`;
            }

            // JS
            let js = 'JS:\n';
            let jscode = '';

            // aggiungi il config della board
            let config = '{\n';
            for (let key in configs[item]) {
                config += '\t' + key + ': ' + configs[item][key].toString() + ', \n';
            }
            config = config.slice(0, -2) + '\n}';

            // if item 11, replace https://cdn.jsdelivr.net/npm/@alepot55/chessboardjs/alepot_theme with 'alepot_theme'
            if (item === 11) {
                config = config.replace('https://cdn.jsdelivr.net/npm/@alepot55/chessboardjs/alepot_theme', "'alepot_theme'");
            }

            jscode += `let config = ${config}; \n`;

            for (let key in buttons[item]) {
                let fname = key.replace(/ /g, '');
                let f = buttons[item][key].toString();

                // rimuovi da f le righe che contengono 'textContainer' se non c'è un 'for'
                if (!f.includes('for')) {
                    f = f.split('\n').filter(x => !x.includes('textContainer')).join('\n');
                }

                // se sono tre righe, rimuovi gli spazi nella seconda riga, metti la prima riga al posto di '{' nella prima

                if (f.split('\n').length === 3) {
                    f = f.split('\n');
                    // rimuovi gli spazi in f[1] finche il primo carattere non è una lettera
                    while (f[1][0] === ' ') f[1] = f[1].slice(1);
                    f[0] = f[0].replace('{', f[1]);
                    f = f[0];
                }


                jscode += `function ${fname}() = ${f} \n`;
            }

            if (jscode.length === 0) return '<xmp>' + html + '</xmp>';

            total += '<xmp>' + html + '\n \n' + js + jscode + '</xmp>';
            return total;
        }

        var coll = document.getElementsByClassName("collapsible");
        for (let i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                for (let j = 0; j < coll.length; j++) {
                    if (j !== i) {
                        coll[j].classList.remove("active");
                        coll[j].nextElementSibling.style.maxHeight = null;
                    }
                }
                active(i);
            });
        }

        function setBoard(config) {
            if (board) board.destroy();
            board = new Chessboard(config);
        }

        var items = document.getElementsByClassName("item");

        for (let i = 0; i < items.length; i++) {
            items[i].addEventListener("click", function () {
                setBoard(configs[i + 1]);
                explanations.innerHTML = texts[i + 1];
                title.innerHTML = items[i].innerHTML;
                codeContainer.innerHTML = getCode(i + 1);
            });
        }

        // Put buttons in description (desc under board)
        for (let i = 0; i < items.length; i++) {
            let button = buttons[i + 1];
            for (let key in button) {

                let btn = document.createElement("button");
                btn.innerHTML = key;
                btn.onclick = button[key];

                // Show button only if the associated item is clicked
                btn.style.display = "none";
                for (let j = 0; j < items.length; j++) {
                    items[j].addEventListener("click", function () {
                        if (i === j) {
                            btn.style.display = "block";
                        } else {
                            textContainer.innerHTML = '';
                            btn.style.display = "none";
                        }
                    });
                }
                btn.className = buttonClass;
                buttonContainer.appendChild(btn);
            }
        }

        // Click on first item and active first button
        items[0].click();
        document.getElementsByClassName(buttonClass)[0].click();


    </script>
</body>

</html>